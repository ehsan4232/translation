overlapping node that has the latest data to ensure consistency. How to configure N, W, and R to fit our use cases? Here are some of the possible setups: If R = 1 and W = N, the system is optimized for a fast read. If W = 1 and R = N, the system is optimized for fast write. If W + R > N, strong consistency is guaranteed (Usually N = 3, W = R = 2). If W + R <= N, strong consistency is not guaranteed. Depending on the requirement, we can tune the values of W, R, N to achieve the desired level of consistency. Consistency models Consistency model is other important factor to consider when designing a key-value store. A consistency model defines the degree of data consistency, and a wide spectrum of possible consistency models exist: • Strong consistency: any read operation returns a value corresponding to the result of the most updated write data item. A client never sees out-of-date data. • Weak consistency: subsequent read operations may not see the most updated value. • Eventual consistency: this is a specific form of weak consistency. Given enough time, all updates are propagated, and all replicas are consistent. Strong consistency is usually achieved by forcing a replica not to accept new reads/writes until every replica has agreed on current write. This approach is not ideal for highly available systems because it could block new operations. Dynamo and Cassandra adopt eventual consistency, which is our recommended consistency model for our key-value store. From concurrent writes, eventual consistency allows inconsistent values to enter the system and force the client to read the values to reconcile. The next section explains how reconciliation works with versioning.